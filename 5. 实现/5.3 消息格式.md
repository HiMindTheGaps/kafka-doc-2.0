消息（也被称为记录）一直是以批量集合的方式写入日志的。一批消息集合的技术术语被称之为`record batch` 。一个记录集合（`record batch`）由一个或者多个记录组成，在最差的情况下，一个记录集合中可能只有一条记录。记录集合和记录本身都有他们自己的 header，下面会依次描述下这两种格式。

## 5.3.1 记录集合

磁盘上一个记录集合的格式如下所示。

```
		baseOffset: int64
		batchLength: int32
		partitionLeaderEpoch: int32
		magic: int8 (current magic value is 2)
		crc: int32
		attributes: int16
			bit 0~2:
				0: no compression
				1: gzip
				2: snappy
				3: lz4
			bit 3: timestampType
			bit 4: isTransactional (0 means not transactional)
			bit 5: isControlBatch (0 means not a control batch)
			bit 6~15: unused
		lastOffsetDelta: int32
		firstTimestamp: int64
		maxTimestamp: int64
		producerId: int64
		producerEpoch: int16
		baseSequence: int32
		records: [Record]
	
```

需要注意的是，当开启压缩模式后，压缩后的记录数据会直接在记录数量的计数之后进行序列化。

CRC 字段涵盖了从 attribute 到集合末尾的全部数据（也就是 CRC 之后的所有字节）。它位于 magic 字段之后，这意味着客户端必须要在决定如何解析集合长度以及 magic 字段之间的字节之前就解析 magic 字段（NOTE：这里的含义应该是说不同版本的消息格式，在集合长度到 magic 之间这段字节内部的字段含义是不同的，但是字节长度相同，所以需要先解析出 magic 字段，然后才知道应该按照哪个版本的消息格式来解析中间这部分字节）。分区 leader 的纪元并不包含在 CRC 字段的计算当中，这样可以避免当 broker 在收到每个集合时还需要重新计算CRC。CRC-32C（Castagnoli）多项式会被用于计算这个字段。

在日志压缩场景中：即使日志已经被清理掉了，magic 值在 v2 以上的消息格式仍然会保留原始集合的第一个以及最后一个 offset/sequence 值，这一点上和更古早的消息格式是不同的。这一点是必要的，只有这样才能在日志重新加载时恢复 producer 的状态。如果我们没有保留最后一个 sequence 值，那么假如一个 partition 的 leader 挂掉了，producer 可能会遇到`OutOfSequence` 错误（NOTE：这里的含义应该是说 producer 的幂等性需要依赖 sequence 这个字段，即使消息被压缩了，那么 sequence 这个字段值应该也需要保留，否则幂等性的判定就会出错）。出于消息重复检查这个功能，baseSequence 这个字段是必须要保留的（broker 会通过验证一个 producer 发上来的消息集合的第一个和最后一个 sequence 值和这个 producer 的最后一个值是否匹配来确认生产的消息是否重复）。这样带来的一个结果就是，日志中会出现一些空集合，因为当一个记录集合中的所有记录都被清理掉之后，这个空集合依然要被留下，这样才能保留下一个 producer 的最后一个 sequence 值。还有一个比较奇怪的现象是，在压缩的过程中，baseTimestamp （NOTE：或许指的是上面消息格式中的 firstTImestamp）字段并不会被保留，因此，如果一个集合中的第一条记录被压缩掉，那么这个字段的值其实是会发生变化的。

### 5.3.1.1 控制集合

一个控制集合仅仅包含唯一一条控制消息记录。控制消息记录不会被传递给应用，它们会交给 consumer 用于过滤掉一些已经被丢弃的事务的消息。

一个控制消息记录的 key 符合下面的 schema：

```
       version: int16 (current version is 0)
       type: int16 (0 indicates an abort marker, 1 indicates a commit)
```

一个控制消息 value 的 schema 依据 key 中的 type 而定，这个 value 对于客户端而言是不透明的。

## 5.3.2 消息记录

消息记录级别的 header 是在 Kafka 0.11.0 版本之后引入的，带有 header 的磁盘消息格式如下：

```
		length: varint
		attributes: int8
			bit 0~7: unused
		timestampDelta: varint
		offsetDelta: varint
		keyLength: varint
		key: byte[]
		valueLen: varint
		value: byte[]
		Headers => [Header]
```

### 5.3.2.1 消息记录 Header

``` 
		headerKeyLength: varint
		headerKey: String
		headerValueLength: varint
		Value: byte[]
```

我们会使用和 Protobuf 相同的变长编码格式。关于 ProtoBuf 更多的信息可以参看[这里](https://protobuf.dev/programming-guides/encoding/#varints)。一个记录中 header 的数量也是由变长字段编码的。

## 5.3.3 老版本消息格式

在 Kafka 0.11 版本之前，消息是以 `message sets` 这种格式进行传输和存储的。在一个消息集合中，每一条消息都拥有自己独立的元数据信息。需要注意的是，尽管消息集合（`message set`）是以数组形式表示的，他们并不会像协议中其他数组元素一样在最前面有一个 int32 表示的数组大小。

**Message Set: **

``` 
MessageSet(Version 0) => [offset messasge_size message]
	offset => INT64
	message_size => INT32
	message => crc magic_byte attributes key value
		crc => INT32
		magic_byte => INT8
		attributes => INT8
			bit 0~2:
				0: no compression
				1: gzip
				2: snappy
			bit 3~7: unused
		key => BYTES
		value => BYTES
```

```
MessageSet(Version 1) => [offset messasge_size message]
	offset => INT64
	message_size => INT32
	message => crc magic_byte attributes key value
		crc => INT32
		magic_byte => INT8
		attributes => INT8
			bit 0~2:
				0: no compression
				1: gzip
				2: snappy
				3: lz4
			bit 3: timestampType
				0: create time
				1: log append time
			bit 4~7: unused
		timestamp => INT64
		key => BYTES
		value => BYTES
```

在 Kafka 0.10 版本之前仅支持 0 这个版本的消息格式（就是 magic 字段所代表的含义）。版本 1 这个消息格式是在 0.10 这个 Kafka 版本所引入的，同时这个版本还引入了时间戳这个字段。

- attributes 字段的最低几位还是用于标识压缩算法，这一点和消息格式版本 2 是相近的。
- 对于 1 这个消息格式版本，producer 应该一直保持将时间戳类型这个字段设置为0。如果这个 topic 配置的是使用 log append time（既可以通过 broker 级别的配置 `log.message.timestamp.type = LogAppendTime` 实现，也可以通过 topic 级别的配置 `message.timestamp.type = LogAppendTime` 来实现），那么 broker 将会重写这个消息集合中的时间戳类型字段以及时间戳字段。

* attributes 的最高几位必须设置为 0。

在消息格式版本为 0 和 1 时，Kafka 支持消息的嵌套用来支持压缩这个功能。在这种场景下，消息的 attributes 字段必须设置为标识压缩算法的其中之一，同时 value 字段就是使用这个压缩算法压缩后的一个消息集合。我们通常将嵌套的消息称之为`inner messages`，将嵌套外层的消息称之为`outer message`。需要注意的是，对于`outer message`而言，key 应该永远为空，同时它的 offset 应该是`inner message` 中的最后一个 offset 值。

当 broker 收到 0 这个版本消息格式的嵌套消息时，broker 会将它解压缩并未每条 `inner message` 赋予一个独立的 offset 值。对于 1 这版本来说，为了避免服务端的重新压缩操作，只有`outer message` 的消息才会被分配 offset 值。`inner message` 只是有一个相对的 offset 值，绝对 offset 值可以通过 `outer message` 的 offset 值计算得到，`outer message` 的 offset 值也就是最后一个 `inner message`  的 offset 值。

crc 字段包含了后续消息字节（比如说从 magic 到 value 之间）的 CRC32（而不是 CRC-32C）。