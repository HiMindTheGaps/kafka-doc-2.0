# 不要惧怕文件系统！

Kafka在数据的存储与缓存方面对文件系统的依赖很重。人们通常会有“磁盘是很慢的”这种看法，这种看法会让人怀疑一个持久化的数据结构是否可以提供很有竞争力的性能表现。不过实际上，磁盘可能比大众眼中的性能表现要更快或者更慢，这取决于我们如何使用它，一种设计合理的磁盘结构很有可能会和网络传输一样快。
硬盘性能一个很重要的现实是：在过去的十年中，硬盘驱动的吞吐量已经完全受限于硬盘寻址的延时。结果就是：在一个`JBOD configuration with six 7200rpm SATA RAID-5 array`磁盘上线性写的性能表现大概是600MB/s，随机写大概只有100kB/s，两者相差了近6000倍。在磁盘的所有使用模式下，线性读写是最容易被预测的，同时操作系统也对此做了很深度的优化。现代操作系统提供了「预读」和「写入延迟」技术，这两种技术可以在读时预先从磁盘上读到连续多块数据，写时将多个小的、零散的逻辑写聚合成一个大块的物理写。关于这个问题更多的讨论可以参见[http://queue.acm.org/detail.cfm?id=1563874](http://queue.acm.org/detail.cfm?id=1563874)，他们确实发现在一些场景下，[顺序的磁盘读写操作甚至要快于内存的随机读写](https://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg)。

为了缩小上述不同使用模式下的性能差异，现代操作系统在将主内存用于做磁盘缓存这项技术上做得十分激进。一个现代操作系统很乐于将所有空闲的内存都用于磁盘缓存，即使如此激进，当内存被回收时也几乎不会有任何性能损耗。所有的磁盘读写操作都会首先经过这个统一的缓存层。这项缓存技术很难关闭，除非使用direct IO，所以说即使一个进程在进程内的内存空间中缓存了一份硬盘数据，这份数据也很有可能在操作系统层面上再缓存一次（页缓存），换句话说，所有磁盘数据都被存成了两副本。

此外，kafka是基于JVM运行的，了解Java内存机制的朋友应该都知道下面这两件事情：

1. 一个Java对象的额外内存开销是很高的，经常是对象真正要存储内容的两倍开销（甚至更多）
2. Java的GC机制在堆内存变大之后会变得很棘手

基于上面一些关于文件系统的讨论以及页缓存优于进程内缓存这个结论，我们通过操作系统自动利用空闲内存这项技术提高了至少一倍的可用缓存空间，而且通过使用一种紧凑的字节结构代替独立Java对象结构来存储数据极有可能使得缓存数据量再翻一倍。经过这样的优化后，在一个32GB内存的物理机上，有多达28GB ~ 32GB的空间可以用来缓存数据，同时还不会引入JVM GC的性能损耗。此外，页缓存即使在服务重启之后依然不会消失，所以服务重启之后是无需缓存预热的；相较之下，进程内内存空间的缓存在服务重启之后就需要在内存中重建缓存（10GB的缓存预热大概要10分钟）。如果不重建缓存，直接冷启动，那初始化的服务性能就太糟糕了。上面提到的这几点优化带来的另一个好处就是极大地简化了代码的复杂度，因为所有维护磁盘以及缓存数据一致性的逻辑都由操作系统完成，它在这方面要比一次性的进程内缓存做得更有效率且更加准确。如果你的磁盘使用习惯偏向于线性读写，那么预读技术会很有效地帮你将每块磁盘上的有用数据预先加载到内存中。

上面所想要阐述的理论很简单：我们的做法不是尽可能多地在进程内的内存中维护数据、在空间不足时一次性的都写到文件系统中。正相反，所有的数据都是立即写到一个文件系统上的持久化日志文件中，如果非必需，数据不会立即刷到磁盘上，所以写磁盘这个操作仅仅意味着将数据写到内核的页缓存中。

这种以页缓存为主的设计风格在这篇关于[Varnish](http://varnish-cache.org/docs/trunk/phk/notes.html)的设计中也有提到。

# 常数时间复杂度

在传统的消息系统中，持久化数据的存储方式通常是一个consumer分配一个队列，同时每个consumer还拥有一个维护消息元数据的随机访问数据结构，比如B树或者其他更通用的数据结构。B树是目前最常用的一种数据结构，它使得消息系统可以支持各种事务性和非事务性的语义。但是B树同时带来的性能损耗也很大，尽管B树的时间复杂度O(log N)一般被认为可以近似等同于常数时间复杂度，但是这个结论在磁盘操作上并不成立。磁盘的寻址耗时每次是10ms左右，而且多块磁盘同一时间只能有一个磁盘寻址操作，并发是很受限的。因此，磁盘寻址操作即使并不频繁，但是往往会造成很高的性能开销。存储系统一般包含高速的内存操作以及低速的物理磁盘操作，当缓存空间恒定不变时，随着数据量不断增加，B树数据结构的整体时间复杂度通常是超线性的，换句话说，数据量翻倍，耗时通常要比翻倍高得多。

直观来讲，持久化队列可以建立在对文件的简单追加以及顺序读这两个操作上，就像日志系统的解决方案那样。这种结构的好处就是所有读写操作的时间复杂度都是O(1)，而且读写之间不会相互阻塞。所以很显然，这种结构的优势就体现在操作耗时完全和数据量无关：一台服务器完全可以使用大量的便宜、低转速、TB数据量级别的SATA存储介质，尽管它们的寻址性能很差，但是这些介质在大数据读写条件下的性能是完全可接受的；同时它们只需要花费1/3的价格，就能给你带来3倍的存储空间。

使用几乎无限的磁盘空间作为消息存储的介质同时没有任何性能损耗，这意味着kafka可以提供一些传统消息系统所不具备的一些特性。比如说，kafka不会在消息被消费之后就立刻删除掉，而是会将消息保留相当长的一段时间（比如一周），这给consumer的使用模式带来了极大的灵活性。